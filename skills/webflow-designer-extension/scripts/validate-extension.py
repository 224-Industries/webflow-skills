#!/usr/bin/env python3
"""
Validate Webflow Designer Extension project structure.
Validates projects created with create-webflow-extension.
Usage: python validate-extension.py [path]
"""

import sys
import os
import json
from pathlib import Path


def validate_extension(project_path: str) -> tuple[bool, list[str]]:
    """Validate a Webflow Designer Extension project structure."""
    path = Path(project_path)
    errors = []
    warnings = []

    # Check project directory exists
    if not path.exists():
        return False, [f"Project path does not exist: {project_path}"]

    if not path.is_dir():
        return False, [f"Path is not a directory: {project_path}"]

    # Required files
    required_files = [
        ("webflow.json", "Extension configuration file"),
        ("package.json", "Node.js package configuration"),
    ]

    for file_path, description in required_files:
        if not (path / file_path).exists():
            errors.append(f"Missing required file: {file_path} ({description})")

    # Validate webflow.json
    webflow_json = path / "webflow.json"
    public_dir_name = "dist"
    if webflow_json.exists():
        try:
            with open(webflow_json, 'r') as f:
                config = json.load(f)

            # Check required fields
            if 'name' not in config:
                errors.append("webflow.json: Missing 'name' field")
            if 'apiVersion' not in config:
                warnings.append("webflow.json: Missing 'apiVersion' field")
            if 'size' not in config:
                warnings.append("webflow.json: Missing 'size' field")
            if 'publicDir' not in config:
                warnings.append("webflow.json: Missing 'publicDir' field (defaults to 'dist')")
            else:
                public_dir_name = config['publicDir']
        except json.JSONDecodeError as e:
            errors.append(f"webflow.json: Invalid JSON - {e}")

    # Validate package.json
    package_json = path / "package.json"
    if package_json.exists():
        try:
            with open(package_json, 'r') as f:
                pkg = json.load(f)

            # Check for required scripts
            scripts = pkg.get('scripts', {})
            if 'dev' not in scripts:
                warnings.append("package.json: Missing 'dev' script (required for development)")
            if 'build' not in scripts:
                warnings.append("package.json: Missing 'build' script (required for production builds)")
        except json.JSONDecodeError as e:
            errors.append(f"package.json: Invalid JSON - {e}")

    # Check publicDir directory
    public_dir = path / public_dir_name
    if not public_dir.exists():
        warnings.append(f"Output directory '{public_dir_name}' does not exist yet (will be created on build)")

    # Check for an HTML entry point (flexible location)
    html_candidates = [
        path / public_dir_name / "index.html",
        path / "src" / "index.html",
        path / "index.html",
    ]
    html_found = any(candidate.exists() for candidate in html_candidates)
    if not html_found:
        warnings.append("No index.html entry point found (may be generated by Rspack during build)")

    # Check for source directory
    src_dir = path / "src"
    if not src_dir.exists():
        warnings.append("No 'src' directory found (expected for TypeScript + React projects)")

    # Print results
    print(f"\nðŸ” Validating: {path.absolute()}\n")

    if errors:
        print("âŒ ERRORS:")
        for error in errors:
            print(f"   â€¢ {error}")
        print()

    if warnings:
        print("âš ï¸  WARNINGS:")
        for warning in warnings:
            print(f"   â€¢ {warning}")
        print()

    if not errors and not warnings:
        print("âœ… All checks passed!")
    elif not errors:
        print("âœ… No critical errors found")

    return len(errors) == 0, errors + warnings


def main():
    project_path = sys.argv[1] if len(sys.argv) > 1 else "."

    success, messages = validate_extension(project_path)

    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
